const { randomId } = require('../generators/random-id');
const { categories, categoryIds } = require('../categories')
module.exports = [
  {
    audienceActivities: [],
    tags: [],
    id: randomId(),
    published: true,
    authorId: 1,
    themeImage: `https://wi-images.condecdn.net/image/oQ7pQBojymp/crop/1440/f/wired-telegrambot.jpg`,
    title: `The AI Telegram bot that abused women is still out of control
    `,
    body:`
    The tech reviewers have spoken: the iPhone 12 Pro Max is another superb iPhone camera. But just how 'pro' is it? We asked photographer Rebecca Scheinberg to spend a day shooting with the new flagship iPhone, focusing on what it can actually do. Here's the verdict.

    The setup
    For my day-to-day work, I shoot on a Phase One P65 Digital Back which is attached to a large format 5x4 camera. It's quite a complicated setup but the reason I have that is the quality of the Digiback and the flexibility I can have with focusing, particularly for my still life work. I also shoot on a range of film cameras, including a Mamiya and sometimes on a Hasselblad.

    For this test, I didn't attempt to take beautiful images, using the camera to create flattering imagery and video, but rather I aimed to test the range and limits of how the camera system on the iPhone 12 Pro Max works.


    Rebecca Scheinberg
    Portraits and aperture
    It's great for portraits and, generally, that's what iPhone cameras are built for. They are very flattering images for people, so I do think that portrait photography is still their strength as opposed to other smartphone brands. The fact that there is now a telephoto lens means you do tend to get better portraits, as a telephoto lens will be less distorted for portraiture. It's a combination of choosing to have that lens in the camera and the processing.

    I like that you can shift the f-stop after you have taken the photo. This meant I could focus on capturing a good expression and lighting, rather than the technical settings. The range of depth of field is quite impressive. It works nicely against a white wall with golden afternoon light.


    Rebecca Scheinberg
    That said, the adjustment does struggle against a textured background at the larger aperture (F/1.4), particularly with fine detail such as the blond curls of my (very patient) partner. So the low f-stop, where it's trying to create this shallow depth-of-field effect, does still feel like a digital alteration. It has always been that way, and it bothers me, so if Apple can get that right, and I know it's really tricky, that would be amazing.

    I also tried a selfie with the front-facing camera versus a photo of myself with the main rear camera. They are very similar in terms of colour accuracy and detail.


    Rebecca Scheinberg
    Focal lengths
    I was impressed by the detail in all three images: 13mm, 26mm and 66mm, left to right. The 26mm came up quite contrasty, with the edges overly defined. Meanwhile the 66mm was impressive. At 100 per cent there is a lot of detail in the fur and the fabric of the cushion.

    Apple iPhone 12 Pro Max: Camera specs

    Wide: 12MP, f/1.6 aperture, dual OIS
    Ultra Wide: 12MP, f/2.4 aperture, 120 degree field of view
    Telephoto: 12MP, f/2.2 aperture, dual OIS
    Optical zoom: 2.5x zoom in, 2x out, 5x 'optical zoom range'
    Digital zoom: Up to 12x digital zoom
    Night mode: Wide, Ultra wide
    Features and modes: Portrait mode, Night mode, LiDAR scanner, Smart HDR 3, Deep Fusion processing, Panorama, Dolby Vision, Apple ProRAW ('coming soon')


    Rebecca Scheinberg
    Light, colour and detail
    The camera handles well lit scenes and I noticed the detail in these images in both the highlights and the lowlights. The colours look quite true to life.

    The iPhone holds up for still life as well. This is the same still-life subject shot at three different focal lengths. Even with this setup of different objects that have different textures, translucence and colours, the iPhone 12 Pro Max's camera held up. The fluorescent pink maintains its colours, and the detail in the wooden objects is clearly defined.


    Rebecca Scheinberg
    Flash Portrait and Night mode
    The flash at night setting was excellent on Portrait mode. The flash wasn't too harsh and combining with Portrait mode meant that it had the potential to be flattering.

    Autofocus in low light is very fast [via the new LiDAR sensor], however I don't feel like this was a feature I was missing. Low-light indoors performed well, though.


    Rebecca Scheinberg
    These photos, taken on each of the focal lengths, were shot in absolute darkness. I had to use the torch on the iPhone to see the path ahead of us. So it is incredible that anything was captured, though the quality is low. If you added a tripod in order to take photographs of landscapes, this could be a really fun feature.

    Controls
    In terms of operating, it was great in terms of the ease of switching between lenses, and you could shift the range easily. It wasn't a button with one option, another option, another option - you could go through the full range from the wide angle to the telephoto.

    In the preview, you could see the potential for if you wanted to go wider or crop in. I liked that, I found it really helpful because it works in a similar way to how I would shoot. Usually I crop in a little bit on an image, because my camera is very high resolution.


    Rebecca Scheinberg
    Editing
    As with iPhones, editing is very user friendly. I did find that a lot of detail was lost if I made more than slight adjustments to the image, though. I enjoyed editing on the screen itself, however. This is where the screen size [6.7inch] comes in handy.

    I know from comparing the iPhone 11 Pro to other smartphone cameras last year that the iPhone tends to do a lot more to the images, whereas, on the Pixel series, the base image was a very high quality that I could then shift the colour palette and contrast however I wanted.

    The Apple ProRAW ['coming soon'] I'm really interested in; it would give me more control over editing my personal photos, which I would enjoy. So that's definitely a plus for me.


    Rebecca Scheinberg
    Video
    I don't do loads of film, but if I did I don't think I'd be using a camera on a phone, so I still feel the uses here would be personal, not professional.

    For this test, I filmed my dog playing fetch on a sunny day, at both frame rates available via the HDR Video/Dolby Vision setting. I was not particularly careful to maintain a level camera and swung it round sharply to follow him. The iPhone's optical image stabilisation handled those adjustments extremely well with almost no shake. It wasn't blown out with the different light changes, it adjusted smoothly. There were some nice lens flares too, which were lovely. Colour and detail was terrific throughout, too, and when HDR video was turned off, the difference was huge with much less detail in the highlights and lowlights.


    Rebecca Scheinberg
    The 'pro' verdict
    I found it quite impressive, the wide range of light conditions that a beautiful photo can be taken in. Some images I took with the iPhone 12 Pro Max were in very dark rooms or as the sun was going down, and the images held up superbly.

    The iPhone also managed to assess the lighting situation well and [via Smart HDR 3] produce the optimal settings, which were not too under- or overexposed. It also handled very bright conditions impressively, maintaining detail in both the shadow and the highlights.

    I love the portability of it and that it gets to a relatively high quality image, but it's just a question of increasing the quality of the image.

    While I still wouldn't use the iPhone to capture professional photographs, I think it takes wonderful personal images and video for home footage.

    I actually have an iPhone 8, so it's quite old. I made that choice because, for my day-to-day, I have better cameras and I was trying to get off my phone a little bit. I found I really enjoyed testing this iPhone with a different camera. It was miles apart. It makes it tempting for me to upgrade.

    `,
    createdAt: new Date('11-18-2020').toString(),
    updatedAt: new Date('11-18-2020').toString(),
    categories: [
      categories.find(category => category.id === categoryIds.tech)
    ]
  },
  {
    audienceActivities: [],
    tags: [],
    published: true,
    id: randomId(),
    authorId: 1,
    themeImage: `https://wi-images.condecdn.net/image/oQ7pQBojymp/crop/1440/f/wired-telegrambot.jpg`,
    title: `About apple new product
    `,
    categories: [
      categories.find(category => category.id === categoryIds.tech)
    ],
    body:`
    The tech reviewers have spoken: the iPhone 12 Pro Max is another superb iPhone camera. But just how 'pro' is it? We asked photographer Rebecca Scheinberg to spend a day shooting with the new flagship iPhone, focusing on what it can actually do. Here's the verdict.

    The setup
    For my day-to-day work, I shoot on a Phase One P65 Digital Back which is attached to a large format 5x4 camera. It's quite a complicated setup but the reason I have that is the quality of the Digiback and the flexibility I can have with focusing, particularly for my still life work. I also shoot on a range of film cameras, including a Mamiya and sometimes on a Hasselblad.

    For this test, I didn't attempt to take beautiful images, using the camera to create flattering imagery and video, but rather I aimed to test the range and limits of how the camera system on the iPhone 12 Pro Max works.


    Rebecca Scheinberg
    Portraits and aperture
    It's great for portraits and, generally, that's what iPhone cameras are built for. They are very flattering images for people, so I do think that portrait photography is still their strength as opposed to other smartphone brands. The fact that there is now a telephoto lens means you do tend to get better portraits, as a telephoto lens will be less distorted for portraiture. It's a combination of choosing to have that lens in the camera and the processing.

    I like that you can shift the f-stop after you have taken the photo. This meant I could focus on capturing a good expression and lighting, rather than the technical settings. The range of depth of field is quite impressive. It works nicely against a white wall with golden afternoon light.


    Rebecca Scheinberg
    That said, the adjustment does struggle against a textured background at the larger aperture (F/1.4), particularly with fine detail such as the blond curls of my (very patient) partner. So the low f-stop, where it's trying to create this shallow depth-of-field effect, does still feel like a digital alteration. It has always been that way, and it bothers me, so if Apple can get that right, and I know it's really tricky, that would be amazing.

    I also tried a selfie with the front-facing camera versus a photo of myself with the main rear camera. They are very similar in terms of colour accuracy and detail.


    Rebecca Scheinberg
    Focal lengths
    I was impressed by the detail in all three images: 13mm, 26mm and 66mm, left to right. The 26mm came up quite contrasty, with the edges overly defined. Meanwhile the 66mm was impressive. At 100 per cent there is a lot of detail in the fur and the fabric of the cushion.

    Apple iPhone 12 Pro Max: Camera specs

    Wide: 12MP, f/1.6 aperture, dual OIS
    Ultra Wide: 12MP, f/2.4 aperture, 120 degree field of view
    Telephoto: 12MP, f/2.2 aperture, dual OIS
    Optical zoom: 2.5x zoom in, 2x out, 5x 'optical zoom range'
    Digital zoom: Up to 12x digital zoom
    Night mode: Wide, Ultra wide
    Features and modes: Portrait mode, Night mode, LiDAR scanner, Smart HDR 3, Deep Fusion processing, Panorama, Dolby Vision, Apple ProRAW ('coming soon')


    Rebecca Scheinberg
    Light, colour and detail
    The camera handles well lit scenes and I noticed the detail in these images in both the highlights and the lowlights. The colours look quite true to life.

    The iPhone holds up for still life as well. This is the same still-life subject shot at three different focal lengths. Even with this setup of different objects that have different textures, translucence and colours, the iPhone 12 Pro Max's camera held up. The fluorescent pink maintains its colours, and the detail in the wooden objects is clearly defined.


    Rebecca Scheinberg
    Flash Portrait and Night mode
    The flash at night setting was excellent on Portrait mode. The flash wasn't too harsh and combining with Portrait mode meant that it had the potential to be flattering.

    Autofocus in low light is very fast [via the new LiDAR sensor], however I don't feel like this was a feature I was missing. Low-light indoors performed well, though.


    Rebecca Scheinberg
    These photos, taken on each of the focal lengths, were shot in absolute darkness. I had to use the torch on the iPhone to see the path ahead of us. So it is incredible that anything was captured, though the quality is low. If you added a tripod in order to take photographs of landscapes, this could be a really fun feature.

    Controls
    In terms of operating, it was great in terms of the ease of switching between lenses, and you could shift the range easily. It wasn't a button with one option, another option, another option - you could go through the full range from the wide angle to the telephoto.

    In the preview, you could see the potential for if you wanted to go wider or crop in. I liked that, I found it really helpful because it works in a similar way to how I would shoot. Usually I crop in a little bit on an image, because my camera is very high resolution.


    Rebecca Scheinberg
    Editing
    As with iPhones, editing is very user friendly. I did find that a lot of detail was lost if I made more than slight adjustments to the image, though. I enjoyed editing on the screen itself, however. This is where the screen size [6.7inch] comes in handy.

    I know from comparing the iPhone 11 Pro to other smartphone cameras last year that the iPhone tends to do a lot more to the images, whereas, on the Pixel series, the base image was a very high quality that I could then shift the colour palette and contrast however I wanted.

    The Apple ProRAW ['coming soon'] I'm really interested in; it would give me more control over editing my personal photos, which I would enjoy. So that's definitely a plus for me.


    Rebecca Scheinberg
    Video
    I don't do loads of film, but if I did I don't think I'd be using a camera on a phone, so I still feel the uses here would be personal, not professional.

    For this test, I filmed my dog playing fetch on a sunny day, at both frame rates available via the HDR Video/Dolby Vision setting. I was not particularly careful to maintain a level camera and swung it round sharply to follow him. The iPhone's optical image stabilisation handled those adjustments extremely well with almost no shake. It wasn't blown out with the different light changes, it adjusted smoothly. There were some nice lens flares too, which were lovely. Colour and detail was terrific throughout, too, and when HDR video was turned off, the difference was huge with much less detail in the highlights and lowlights.


    Rebecca Scheinberg
    The 'pro' verdict
    I found it quite impressive, the wide range of light conditions that a beautiful photo can be taken in. Some images I took with the iPhone 12 Pro Max were in very dark rooms or as the sun was going down, and the images held up superbly.

    The iPhone also managed to assess the lighting situation well and [via Smart HDR 3] produce the optimal settings, which were not too under- or overexposed. It also handled very bright conditions impressively, maintaining detail in both the shadow and the highlights.

    I love the portability of it and that it gets to a relatively high quality image, but it's just a question of increasing the quality of the image.

    While I still wouldn't use the iPhone to capture professional photographs, I think it takes wonderful personal images and video for home footage.

    I actually have an iPhone 8, so it's quite old. I made that choice because, for my day-to-day, I have better cameras and I was trying to get off my phone a little bit. I found I really enjoyed testing this iPhone with a different camera. It was miles apart. It makes it tempting for me to upgrade.

    `,
    createdAt: new Date('11-18-2020').toString(),
    updatedAt: new Date('11-18-2020').toString(),
  },
  {
    audienceActivities: [],
    tags: [],
    published: true,
    id: randomId(),
    authorId: 1,
    themeImage: `https://cdn.cnn.com/cnnnext/dam/assets/201023030806-huawei-earnings-china-tech-hnk-into-medium-plus-169.jpg`,
    title: `Huawei is shrinking its smartphone business in a fight to save the brand
    `,
    categories: [
      categories.find(category => category.id === categoryIds.tech)
    ],
    body:`
    Hong Kong (CNN Business)Huawei has been battered by a long US campaign against the company. Now it is hunkering down for survival by selling off its budget smartphone business.

    A consortium of buyers said on Tuesday that it has acquired Huawei's Honor smartphone brand for an undisclosed amount of money. The buyers include more than 30 Chinese agents and dealers of the budget brand.
    Huawei and the group of buyers said they struck the deal to help save Honor's supply chain, and protect consumers and sellers. The Trump administration has cut off the Chinese company's access to vital technology, such as chipsets and software for its smartphones and 5G telecommunications equipment. Washington says Huawei poses a national security threat, allegations the company has long denied.
    Huawei says &#39;survival is the goal&#39; as US crackdown hammers its business
    Huawei says 'survival is the goal' as US crackdown hammers its business
    Ditching Honor gives Huawei's main smartphone brand more of a fighting chance
    It is also a much needed reprieve for Huawei. Selling Honor means the embattled Shenzhen company can now free up resources to focus on its own brand of flagship smartphones, according to Nicole Peng, analyst at market research firm Canalys.
    Huawei stockpiled inventory before the latest round of restrictions were announced earlier this year. Still, its rotating chief executive said at a conference in September that the company is in a "difficult situation" and "survival is the goal."
    "Survival means they need to make sure they have enough components to have business continuity for a longer period of time," said Peng. Offloading Honor will give Huawei's smartphone unit a bit of breathing room.
    "It definitely will be much less burden on their shoulders," said Peng. "They only have a limited supply of components. At least those can [now] be preserved for the higher end Huawei brand," she added.
    Huawei will not hold any shares or be involved in any business management or decision-making activities in the new Honor company, according to a company statement.
    Which means "Honor should be able to source their own components ... [and] sign their own contracts," according to Peng.
    Huawei&#39;s sales growth slows as US sanctions bite
    Huawei's sales growth slows as US sanctions bite
    It is possible that US sanctions on Huawei could ease once President-elect Joe Biden takes office. But there is no guarantee that a Biden administration will roll back restrictions on the Chinese tech firm.
    Huawei's "future and outlook is still very uncertain," said Will Wong, analyst with market research firm IDC. "So they need to focus on what they have, and the best thing they have are the high-end models."
    The company's flagship phones such as the P and Mate series sell for upwards of about 4,500 yuan ($683) and 6,400 yuan ($972), respectively. Honor phones are much cheaper — the latest 10X series starts at around 2,100 yuan ($319) and lower end Play phones sell for as little as 1,200 yuan ($183).
    Focusing on the flagship devices will help Huawei "maintain their high-end brand image and also generate more revenue," said Wong.
    Losing Honor will hit Huawei's global smartphone ranking
    Without Honor, Huawei's total smartphone sales will take a hit.
    Earlier this year, the company achieved its long-time goal and briefly became the world's top smartphone seller, helped by a slump in sales at rival Samsung.
    The achievement would not have been possible without Honor. For nearly the last two years, the budget brand has accounted for between 25% and 29% of Huawei's total smartphone shipments, according to data from IDC. Canalys, which uses a different method to calculate shipments, found that Honor accounted for 20% to 40% of Huawei's total sales.
    In the second quarter this year, the period when Huawei eked out a win over its South Korean rival, Honor made up more than a quarter of the company's total smartphone sales, according to IDC and Canalys. Without the roughly 15 million Honor devices sold in the April-June quarter, Huawei would not have landed on top of the podium.
    Samsung already regained the top spot in the July-September quarter, with Huawei taking second place for global smartphone sales, according to IDC and Canalys. Without Honor phones, Huawei would have been bumped to the No. 3 spot, behind Chinese smartphone maker Xiaomi.
    `,
    createdAt: new Date('11-09-2020').toString(),
    updatedAt: new Date('11-09-2020').toString(),
  },
  {
    audienceActivities: [],
    tags: [],
    published: true,
    categories: [
      categories.find(category => category.id === categoryIds.tech)
    ],
    id: randomId(),
    authorId: 1,
    themeImage: null,
    title: `    How To Fix Laravel CSRF Token Mismatch Error From AJAX Request

    `,
    body:`
    How To Fix Laravel CSRF Token Mismatch Error From AJAX Request
As I’ve mentioned in previous posts about CSRF tokens, Laravel actively checks certain requests for CSRF tokens for validation. If this isn’t validated correctly, one of the most common errors you will receive is ‘CSRF token mismatch‘. The use-case in which you generally experience this mismatch error is during requests that are sent with AJAX or similar.

Let’s take the following JavaScript AJAX request for example.

$.ajax({
                type: 'POST',
                url:  '/api/myApiUrl',
                data: myObject
                success: function (data) {
                    console.log(data);
                }
});Copy
This request, when executed will receive a response in the console that there is a CSRF token mismatch.

So, how do we fix it?
Well, there are a couple of methods and either one is perfectly fine and pretty much depends on your own preference.

But first of all, to ensure that you can reference the CSRF token in both your HTML file and JavaScript files alike, a meta tag must be present in your <head> section.

To check this, have a look in your layout files where the <head> section is defined and look for the following code snippet –

<meta name="csrf-token" content="{{ csrf_token() }}">Copy
If you cannot find it, then add it to the file.

Method 1
Adding a new AJAX ‘header’.

Add the following code snippet into your <script> section, prior to the AJAX call.

$.ajaxSetup({
            headers: {
                'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
            }
});Copy
This snippet will pre-set the AJAX header by grabbing the csrf-token from the meta tag named csrf-token as explained earlier. It is the simplest way to go, especially if you have multiple AJAX calls assigned to different functionality like filters or buttons.

Method 2
Passing the token as a data property along with any other information that will be sent via AJAX.

Within the AJAX call itself, add another data property alongside the data that will be passed already.

$.ajax({
    type: 'POST',
    url: '/api/myApiUrl',
    data: {"myObj": myObject, "_token": "{{ csrf_token() }}"},
    success: function (data) {
        console.log(data);
    }
});
Summary
And that is it, using either one of these methods will ensure that the CSRF token is always sent with your HTTP requests with AJAX or similar. These methods will rid the error of CSRF token mismatch and validate it correctly with Laravel every time.


    Samsung already regained the top spot in the July-September quarter, with Huawei taking second place for global smartphone sales, according to IDC and Canalys. Without Honor phones, Huawei would have been bumped to the No. 3 spot, behind Chinese smartphone maker Xiaomi.
    `,
    createdAt: new Date('10-09-2020').toString(),
    updatedAt: new Date('10-09-2020').toString(),
  },
  {
    audienceActivities: [],
    tags: [],
    published: true,
    categories: [
      categories.find(category => category.id === categoryIds.tech)
    ],
    id: randomId(),
    authorId: 1,
    themeImage: null,
    title: `Huawei is shrinking its smartphone business in a fight to save the brand
    `,
    body:`
    SEPTEMBER 4, 2019
How To Make Tree Visualizations with JavaScript and SVG Tutorial
In this article, we’ll go step by step through the process of rendering tree structures in the browser with Scalable Vector Graphics.  By the end of this post, you will have a general framework for visualizing data-driven trees that you can apply to all kinds of domains.  We’ll be using the Reingold-Tilford algorithm to automatically produce aesthetically pleasing trees from whatever data we feed into it.

See the screenshot below of what we are going to build –

visualization tree



You can see the demo in action and read the final code here.  In the interest of focusing on the core algorithm, I won’t be covering the details of the final rendering operation.  The linked demo, however, contains all of the code if you’d like to see that as well.

Let’s look at an overview of the steps we’ll take to arrive at the solution before starting.

Create the shell of the code we’ll be working with.  This will mean an HTML template and the outline of the JavaScript that will be responsible for the rendering.
Write the code that will transform our input data for the tree rendering algorithm to consume.
Implement the first stage of the algorithm that calculates initial positions for each node in the tree.
Implement code that re-positions children in order to center them under their parent.
Finally, we’ll write code to fix any overlaps that occur within the tree.
Getting started
The project will consist of a single HTML file, a separate file for the accompanying JavaScript, and some CSS.  To begin, I’ll walk through the initial HTML and the shell of the JavaScript.

<html>
    <head>
        <link rel="stylesheet" href="/styles.css" />
        <script src="/tree.js"></script>
    </head>
    <body>
        <h1>Tree Drawing Algorithm</h1>
        <svg viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet">
            <g transform="translate(0, 50)"></g>
        </svg>
        <script>
            let root = {
                value: "A",
                children: [
                    {
                        value: "B",
                        children: []
                    },
                    {
                        value: "C",
                        children: []
                    }
                ]
            };

            let svgNode = document.querySelector("svg g");

            let renderer = new TreeRenderer(root, svgNode);
            renderer.draw();
        </script>
    </body>
</html>Copy
The svg g element will be the target of our drawing operations.  An SVG g element acts as a container that will allow us to shift everything inside of it using the transform property.  This is useful when applying padding to prevent overflow.

The viewBox attribute is used to define an independent coordinate space.  As a result, this allows us to work without having to account for the different dimensions that the container may end up having.

Additionally, the preserveAspectRatio attribute controls the scaling behavior of the SVG element.  Here we are telling the browser to scale up the result as much as possible and to center everything.

The script tag is placed after the SVG container because we’ll need a reference to the container when we begin the rendering process.  The container would not exist yet if we had placed the script at the top of our HTML file.

The root variable represents the first tree that we are going to render.  Every node in the tree contains a value and references to its children.  This first tree contains only three nodes, but that will be enough to explain the fundamental concepts.  Finally, we declare an instance of the TreeRenderer class that will be responsible for turning our input data into a rendered tree.

Now let’s take a look at the shell of the JavaScript code that we’ll fill in.

There’s a lot of code here, but these are the four essential tasks that it accomplishes:

Consume the input data and produce a format prepared for the algorithm to consume.
Space out nodes within the same level.
Adjust children so that they are centered with respect to their parent.
Shift entire subtrees down that overlap with other subtrees.
class TreeNode {
    constructor(value) {
        this.x = 0;
        this.y = 0;

        this.value = value;

        this.final = 0;
        this.modifier = 0;

        this.prevSibling = null;
        this.children = [];
    }

    visit(func) {
        func(this);
        for (let i = 0; i < this.children.length; i++) {
            this.children[i].visit(func);
        }
    }
}

class TreeRenderer {
    constructor(dataRoot, svgNode, width = 1000, height = 100) {
        // The root of the JavaScript object that represents the data
        // that we'll be rendering.
        this.dataRoot = dataRoot;

        // The SVG DOM node that the renderer will insert elements into.
        this.svgNode = svgNode;

        this.width = width;
        this.height = height;

        this.nodeRoot = this.prepareData(this.dataRoot, 0, null);

        this.firstPass(this.nodeRoot);
        this.secondPass(this.nodeRoot, 0);
        this.fixNodeConflicts(this.nodeRoot);
        this.shiftTreeIntoFrame();
    }

    /*
     * Build an intermediate form of the original data tree.  The nodes of
     * this new tree will be instances of the TreeNode class.
     */
    prepareData(node, level, prevSibling) {}

    /*
     * Assign initial position values to every node based on how many
     * prior siblings the current node has.
     */
    firstPass(node) {}

    /*
     * Adjust the position of children such that they end up centered
     * under their parent.
     */
    secondPass(node, modSum) {}

    /*
     * Work from the end of the tree back toward the beginning, fixing any
     * subtree overlap as we recurse through the tree.
     */
    fixNodeConflicts(node) {}
}Copy
We’ll go step by step and fill in each missing piece.

Preprocessing the data
The goal of the prepareData method is to take our input tree and produce an identical tree made up of TreeNode instances.  We do this because there is additional information that we need to store somewhere to be used in later stages of the algorithm.  In order to determine the tree layout, each node must remember its own x and y position.  Additionally, each node maintains modifier and final values that are used to make adjustments in the second pass of the algorithm.  We’ll go into the meaning of each value in more detail as we implement the TreeRenderer methods.

prepareData(node, level, prevSibling) {
        let treeNode = new TreeNode(node.value);
        treeNode.x = level;
        treeNode.prevSibling = prevSibling;

        for (let i = 0; i < node.children.length; i++) {
            treeNode.children.push(
                this.prepareData(
                    node.children[i],
                    level + 1,
                    i >= 1 ? treeNode.children[i - 1] : null
                )
            );
        }
        return treeNode;
    }Copy
After preprocessing the data we have a set of TreeNode instances that hold references to their parent and sibling.  Each node also knows the tree level in which they reside.

Calculating initial positions
We have created our TreeNode instances, but all of their layout values have defaulted to zero.  Our tree, if we rendered it now, would collapse into a single point.

Although I’ll show you how to render the tree in any orientation, for this article we’ll think of the tree as rendered from left to right. Because of that default orientation, calculating the x value of each node will be very simple.  The total available width (in the independent SVG coordinate space) divided by the number of tree levels will determine the space between levels.  Therefore, the x value of a node is its tree-level multiplied by the space per level.

In fact, the prepareData method has already assigned a level to each node, so this calculation should be straightforward.

The y value, however, is where most of the complexity comes from.  Finding the correct y values is a three-step process.

In the first step, we’ll derive initial values based on how many siblings a node has.  Let’s take a look at that code and walk through it.

firstPass(node) {
        for (let i = 0; i < node.children.length; i++) {
            this.firstPass(node.children[i]);
        }

        if (node.prevSibling) {
            node.y = node.prevSibling.y + NODE_SEP;
        } else {
            node.y = 0;
        }

        if (node.children.length == 1) {
            node.modifier = node.y;
        } else if (node.children.length >= 2) {
            let minY = Infinity;
            let maxY = -minY;
            for (let i = 0; i < node.children.length; i++) {
                minY = Math.min(minY, node.children[i].y);
                maxY = Math.max(maxY, node.children[i].y);
            }
            node.modifier = node.y - (maxY - minY) / 2;
        }
    }Copy
The method is a post-order traversal of the tree, meaning that we start assigning values from bottom to top and right to left. This is important because the y value of each node depends on the y value of its previous sibling.  The modifier value of the current node comes from finding the midpoint of the children.  This will be used later, in the second pass, to shift children so that they end up centered relative to their parent.

This is what our tree would look like if we rendered it after this first step:

tree-drawing-parents-unaligned

Each node is populated with its final position value.  After this first step, each level of the tree would have a correct layout, but parents are not centered over their children.  To fix this, the second pass will use modifier values to pull the children in the right direction.

Centering nodes using position modifiers
In this next step, we’ll utilize the modifier values to offset the children of each node so that they are centered.

secondPass(node, modSum) {
        node.final = node.y + modSum;
        for (let i = 0; i < node.children.length; i++) {
            this.secondPass(node.children[i], node.modifier + modSum);
        }
    }Copy
Unlike the first pass, here we’re using a pre-order traversal because we want the effect of the modifier to be compounding. While recursing through the tree and shifting nodes, we will carry the effect of each shift through the rest of that subtree via the modSum value.

We will use the final value to determine y-axis position when rendering the tree.  This is how the previous example tree will appear after executing the second pass:

tree-drawing-parents-aligned

Our trees are looking pretty good at this point, but there is still another important issue that our algorithm needs to contend with.

Fixing node conflicts
Neighboring nodes are going to overlap when they have too many children.  This happens because the first and second passes of the algorithm don’t take into account the subtrees of their neighbors.  After two neighboring nodes have spaced out their children and centered them, it’s fairly easy for their respective subtrees to end up overlapping.

Let’s take a look at this issue in action.

tree-drawing-with-overlaps

Here we have nodes A-G, where C is a child of B.  E, F, and G are children of D.  Unfortunately, E has completely covered up C.  Fixing this issue involves tracing the subtree contour of each node and essentially pushing one of the subtrees down and out of the way.  In this example, C defines the bottom contour of B, while E defines the top contour of D.

The following code finds the contours and pushes the bottom subtree down according to how much overlap was discovered.

fixNodeConflicts(node) {
        for (let i = 0; i < node.children.length; i++) {
            this.fixNodeConflicts(node.children[i]);
        }

        for (let i = 0; i < node.children.length - 1; i++) {
            // Get the bottom-most contour position of the current node
            let botContour = -Infinity;
            node.children[i].visit(
                node => (botContour = Math.max(botContour, node.final))
            );

            // Get the topmost contour position of the node underneath the current one
            let topContour = Infinity;
            node.children[i + 1].visit(
                node => (topContour = Math.min(topContour, node.final))
            );

            if (botContour >= topContour) {
                node.children[i + 1].visit(
                    node => (node.final += botContour - topContour + NODE_SEP)
                );
            }
        }
    }Copy
We’ll have a much better-looking tree once we adjust the final values to account for overlaps.

tree-drawing-with-overlaps-fixed

Changing orientation
Luckily, changing the orientation of the output is fairly easy, thanks to SVG.  Instead of having to make alterations to the code we’ve already written, we can use SVG transforms to rotate the original output.

After updating the HTML to add a rotation to the g container element:

<svg viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet">
    <g transform="translate(550, 50) rotate(90)"></g>
</svg>Copy
The output will be rotated:



In conclusion
I hope this post will give you a template that you can customize for your own applications. Although we covered the core of the algorithm, not every line of code is included in this post, so please refer to this link if you’d like to dive into the details.

`,
    createdAt: new Date('11-08-2020').toString(),
    updatedAt: new Date('11-08-2020').toString(),
  },
  {
    audienceActivities: [],
    tags: [],
    published: true,
    categories: [
      categories.find(category => category.id === categoryIds.tech)
    ],
    id: randomId(),
    authorId: 1,
    themeImage: null,
    title: `Huawei is shrinking its smartphone business in a fight to save the brand
    `,
    body:`JQuery AJAX Loading Spinners Tutorial with Examples
    Loading spinners are awesome, and there are a lot of them available from a variety of sources. One of these is loading.io, a service that helps you create loading animations with icons, GIF’s, SVG’s and even backgrounds.

    If you’ve ever or are currently working with a highly-dynamic data analysis web project, then you will of come to know that requesting data via AJAX is very common. Now, rather than just have some simple ‘Loading’ message presented to the user when a button is clicked, for instance, we can show something much nicer, a spinner.

    In this tutorial, we will add one of the loading.io icon spinners to an ajax call, so that the user can visually see that the process is happening during a request.



    First of all, let’s pick a spinner, I chose the one below –


    These spinners are EXTREMELY easy to set up, all you need to do is copy the provided CSS into your stylesheet and copy the HTML tag provided into your HTML, that is it!

    For the example I’ve used, here is the CSS required –

    .lds-dual-ring {
      display: inline-block;
      width: 80px;
      height: 80px;
    }
    .lds-dual-ring:after {
      content: " ";
      display: block;
      width: 64px;
      height: 64px;
      margin: 8px;
      border-radius: 50%;
      border: 6px solid #fff;
      border-color: #fff transparent #fff transparent;
      animation: lds-dual-ring 1.2s linear infinite;
    }
    @keyframes lds-dual-ring {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }Copy
    And the HTML

    <div class="lds-dual-ring"></div>Copy
    And boom, you’ve got yourself a spinner, All in a minutes work. I dare even say next to zero coding experience is needed!

    Next up, we need some data, and I’ve found a pretty simple API that allows you to call it without any API token. It’s data from the Forbes rich list so we can request the top 400 richest people in the world. – Check it out using the URL – https://forbes400.herokuapp.com/api/forbes400?limit=400



    So, now we have a spinner, some data, alls is left to do is add a button to click and some JQuery to handle the button click and subsequently execute the AJAX call.

    Step 1

    Add the following HTML to your .html file.

    <button id='getDataBtn'>Get Data</button>

    <div id="richList"></div>


    <div id="loader" class="lds-dual-ring hidden overlay"></div>Copy
    Notes:

    Get Data button will be listened for via JQuery and execute the Ajax once pressed.
    The richList div element will be used to put in the list of people returned from the API.
    The loader element will sit hidden away (note: hidden class added) prepared to be brought into view. Also, note the overlay class which I will explain later.
    Step 2

    Add the following CSS between some <style> tags or into your CSS file –

    body {
            background: #ececec;
        }
        /*Hidden class for adding and removing*/
        .lds-dual-ring.hidden {
            display: none;
        }

        /*Add an overlay to the entire page blocking any further presses to buttons or other elements.*/
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: rgba(0,0,0,.8);
            z-index: 999;
            opacity: 1;
            transition: all 0.5s;
        }

        /*Spinner Styles*/
        .lds-dual-ring {
            display: inline-block;
            width: 80px;
            height: 80px;
        }
        .lds-dual-ring:after {
            content: " ";
            display: block;
            width: 64px;
            height: 64px;
            margin: 5% auto;
            border-radius: 50%;
            border: 6px solid #fff;
            border-color: #fff transparent #fff transparent;
            animation: lds-dual-ring 1.2s linear infinite;
        }
        @keyframes lds-dual-ring {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }Copy
    Notes:

    The .hidden class will be used for the spinner as a default loading state so that the user doesn’t see it. We toggle this on and off with JQuery.
    The .overlay class will add a full-screen overlay with the spinner and on top of any other on-screen elements. This prevents users from clicking anything else during the load stage. Always a good idea!
    The rest of the styles are required for the spinner itself.
    Step 3

    Add the following JavaScript to your .html page or in its own script file.

    // Define our button click listener
        $('#getDataBtn').click(function () {

            // On click, execute the ajax call.
            $.ajax({
                type: "GET",
                url: "https://forbes400.herokuapp.com/api/forbes400?limit=400",
                dataType: 'json',
                beforeSend: function () { // Before we send the request, remove the .hidden class from the spinner and default to inline-block.
                    $('#loader').removeClass('hidden')
                },
                success: function (data) {
                    // On Success, build our rich list up and append it to the #richList div.
                    if (data.length > 0) {
                        let richList = "<ol>";
                        for (let i = 0; i < data.length; i++) {
                            console.log(data[i].uri);
                            richList += "<li>" + data[i].uri + "</li>";
                        }
                        richList += "</ol>"
                        $('#richList').html(richList);
                    }
                },
                complete: function () { // Set our complete callback, adding the .hidden class and hiding the spinner.
                    $('#loader').addClass('hidden')
                },
            });
        });Copy
    Notes:

    We define a click handler to listen for button clicks
    Once the button is clicked we start the Ajax functionality
    We define the URL and data type and then use the beforeSend function to show our spinner by removing the .hidden class from the spinner element. Now the spinner is overlaid and spinning the user can see the request is in progress and can’t interrupt it by clicking anything else.
    With the success function, we build up our HTML from the API response, building a numbered list with the names of all the people on the API list. Then we append the HTML to the #richList element.
    In the complete callback function, we finally add the .hidden class back to the spinner, hiding it away until next required.


    Now, if we put this all together within a CodePen the result will be as the following –

    Hit the GetData button to request the data and see the spinner in action.




    Summary
    Using this ten-minute tutorial you can totally transform your user’s experience when requesting data, whether it be to add new data to a data table, download an excel file or load data into a chart. The method of overlaying with CSS also brings a new element of preventing any unwanted further clicks on the button or other elements. Of course, you can handle this in different ways but this is a quick and simple method.

    Loading.io has plenty of spinners and other loading animations and is well worth looking at. Check them out here.

`,
    createdAt: new Date('11-20-2020').toString(),
    updatedAt: new Date('11-20-2020').toString(),
  },
];
